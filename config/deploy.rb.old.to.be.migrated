# capistrano 2.3.0 deploy script
require 'mongrel_cluster/recipes'

set :default_environment, {
	'PATH' => "/home/amir/.rvm/gems/ruby-1.8.7-p374@icanlocalize/bin:/home/amir/.rvm/rubies/ruby-1.8.7-p374/bin:$PATH",
	'GEM_HOME'     => '/home/amir/.rvm/gems/ruby-1.8.7-p374@icanlocalize/',
	'GEM_PATH'     => '/home/amir/.rvm/gems/ruby-1.8.7-p374@icanlocalize/',
}

# This defines a deployment "recipe" that you can feed to capistrano
# (http://manuals.rubyonrails.com/read/book/17). It allows you to automate
# (among other things) the deployment of your application.

# =============================================================================
# REQUIRED VARIABLES
# =============================================================================
# You must always specify the application and repository for every recipe. The
# repository must be the URL of the repository you want this recipe to
# correspond to. The deploy_to path must be the path on each machine that will
# form the root of the application path.



# =============================================================================
# ROLES
# =============================================================================
# You can define any number of roles, each of which contains any number of
# machines. Roles might include such things as :web, or :app, or :db, defining
# what the purpose of each machine is. You can also specify options that can
# be used to single out a specific subset of boxes in a particular role, like
# :primary => true.

role :web, "www.icanlocalize.com"
role :app, "www.icanlocalize.com"
role :db,  "www.icanlocalize.com", :primary => true

# =============================================================================
# OPTIONAL VARIABLES
# =============================================================================
set :application, "icanlocalize"
set :user, "amir" # user that will run the commands on the server
set :use_sudo, false

set :scm, "git"
set :branch, "master"
#set :deploy_via, :remote_cache
set :repository, "ssh://git@git.onthegosystems.com:10022/icanlocalize/icanlocalize.git"

set :target, fetch(:target)
case target
when "production"
  set :rails_env, "production"
  set :deploy_to, "/home/amir/rails/#{application}"
  set :mongrel_conf, "#{current_path}/config/mongrel_cluster.yml"
  set :thin_conf, "#{current_path}/config/thin_production.yml"
  set :branch, "master"
  set :webserver, "thin"
when "sandbox"
  set :rails_env, "sandbox"
  set :deploy_to, "/home/amir/sandbox/#{application}"
  set :mongrel_conf, "#{current_path}/config/mongrel_cluster_sandbox.yml"
  set :thin_conf, "#{current_path}/config/thin_sandbox.yml"
  set :branch, "sandbox"
  set :webserver, "thin"
else
  raise "You need to give a target. Ex: cap deploy -S target=sandbox"
end

# =============================================================================
# SSH OPTIONS
# =============================================================================
ssh_options[:forward_agent] = true
ssh_options[:compression] = "none"

desc "Bundle install"
task :bundle_install do
  run "cd #{release_path}; bundle install"
end

desc "Run pending migrations"
task :db_migrate do
  run "cd #{release_path}; Rails.env=#{rails_env} bundle exec rake db:migrate"
end

task :rebuild_assets, :roles => [:web] do
  run <<-EOF
    cd #{release_path} &&
    rake Rails.env=production asset:packager:build_all
  EOF
end

task :add_my_symlinks do
  run "ln -nfs #{deploy_to}/private #{current_release}"
  run "ln -nfs #{deploy_to}/index #{current_release}"
  run "ln -nfs #{shared_path}/system #{current_release}/public"
  run "ln -nfs #{deploy_to}/shared/captcha_images #{current_release}/public"
  run "ln -nfs #{deploy_to}/shared/images_production #{current_release}/public/images/production"
  run "ln -nfs #{deploy_to}/shared/cgi-bin/tmp #{current_release}/cgi-bin"
  run "ln -nfs #{deploy_to}/shared/cgi-bin/sqlite-db #{current_release}/cgi-bin"
end

task :stop_tas do
  if rails_env == "production"
    run "/usr/bin/python2.5 /home/amir/python.devel/translation_assistant/TAS_TCP_server.py stop #{rails_env}"
  else
    run "/usr/bin/python2.5 /home/amir/python.devel/ta_tp/TAS_TCP_server.py stop #{rails_env}"
  end
end

task :start_tas do
  if rails_env == "production"
    run "/usr/bin/python2.5 /home/amir/python.devel/translation_assistant/TAS_TCP_server.py start #{rails_env}"
  else
    run "/usr/bin/python2.5 /home/amir/python.devel/ta_tp/TAS_TCP_server.py start #{rails_env}"
  end
end

task :allow_execute do
  run "chmod +x #{current_path}/script/runner"
  run "chmod +x #{current_path}/script/process/spawner"
  run "chmod +x #{current_path}/script/process/reaper"
  run "chmod +x #{current_path}/script/process/inspector"
end

namespace :deploy do

  namespace :web do
    desc "Enable maintenance mode for apache"
    task :disable, :roles => :web do
      on_rollback { run "rm -f #{shared_path}/system/maintenance.html" }
      page = File.read('public/maintenance.html')
      put page, "#{shared_path}/system/maintenance.html", :mode => 0644
    end

    desc "Disable maintenance mode for apache"
    task :enable, :roles => :web do
      run "rm -f #{shared_path}/system/maintenance.html"
    end
  end

  namespace :mongrel do
    [ :stop, :start, :restart ].each do |t|
      desc "#{t.to_s.capitalize} the mongrel appserver"
      task t, :roles => :app do
        #invoke_command checks the use_sudo variable to determine how to run the mongrel_rails command
        invoke_command "cd #{current_path}; bundle exec mongrel_rails cluster::#{t.to_s} -C #{mongrel_conf}", :via => run_method
      end
    end
  end

  namespace :thin do
    [ :stop, :start, :restart ].each do |t|
      desc "#{t.to_s.capitalize} the thin appserver"
      task t, :roles => :app do
        invoke_command "cd #{current_path}; bundle exec thin #{t.to_s} -C #{thin_conf} -c #{current_path}", :via => run_method
      end
    end
  end

  desc "Custom restart task for mongrel cluster"
  task :restart, :roles => :app, :except => { :no_release => true } do
    case webserver 
    when "mongrel"
      deploy.mongrel.stop
      sleep 1
      deploy.mongrel.start
      sleep 3
      deploy.mongrel.start  
    when "thin"
      deploy.thin.stop
      sleep 1
      deploy.thin.start
    end
  end

  desc "Custom start task for mongrel cluster"
  task :start, :roles => :app do
    case webserver 
    when "mongrel"
      deploy.mongrel.start  
    when "thin"
      deploy.thin.start
    end
  end

  desc "Custom stop task for mongrel cluster"
  task :stop, :roles => :app do
    case webserver 
    when "mongrel"
      deploy.mongrel.stop
    when "thin"
      deploy.thin.stop
    end
  end

  namespace :delayed_job do
    def rails_env
      fetch(:rails_env, false) ? "Rails.env=#{fetch(:rails_env)}" : ''
    end
    def args
      fetch(:delayed_job_args, "")
    end
    def roles
      fetch(:delayed_job_server_role, :app)
    end

    desc "Stop the delayed_job process"
    task :stop, :roles => lambda { roles } do
      run "cd #{current_path};#{rails_env} script/delayed_job stop"
    end

    desc "Start the delayed_job process"
    task :start, :roles => lambda { roles } do
      run "cd #{current_path};#{rails_env} script/delayed_job start #{args}"
    end

    desc "Restart the delayed_job process"
    task :restart, :roles => lambda { roles } do
      run "cd #{current_path};#{rails_env} script/delayed_job restart #{args}"
    end
  end
end


before 'deploy:update_code', :stop_tas
after 'deploy:update_code', :bundle_install
after 'deploy:update_code', :db_migrate
after 'deploy:update_code', :rebuild_assets
after 'deploy:symlink', :add_my_symlinks
before 'deploy:restart', :allow_execute
before 'deploy:restart', 'deploy:web:disable'
after 'deploy:restart', :start_tas
after 'deploy:restart', 'deploy:web:enable'
